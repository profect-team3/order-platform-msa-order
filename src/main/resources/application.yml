spring:
  application:
    name: order
  config:
    import: optional:file:.env[.properties]
  datasource:
    url: ${DB_URL}
    username: ${DB_USERNAME}
    password: ${DB_PASSWORD}
    driver-class-name: org.postgresql.Driver

  jpa:
    database-platform: org.hibernate.dialect.PostgreSQLDialect
    hibernate:
      ddl-auto: none
    properties:
      hibernate:
        format_sql: true
        show_sql: true
        use_sql_comments: true

  data:
    redis:
      host: ${REDIS_HOST}
      port: ${REDIS_PORT}
      password: ${REDIS_PASSWORD}
      database: 0
    mongodb:
      host: localhost
      port: 27017
      database: store-db
      username: ${MONGO_INITDB_ROOT_USERNAME}
      password: ${MONGO_INITDB_ROOT_PASSWORD}
      authentication-database: admin
#  batch:
#    job:
#      enabled=false:

  security:
    oauth2:
      resourceserver:
        jwt:
          jwk-set-uri: http://localhost:8083/oauth/jwks

jwt:
  audience:  ${AUTH_INTERNAL_AUDIENCE:internal-services}

logging:
  level:
    org:
      springframework:
        data:
          mongodb:
            core:
              MongoTemplate: DEBUG

discord:
  webhook:
    url: ${DISCORD_URL}

resilience4j:
  circuitbreaker:
    configs:
      default:
        waitDurationInOpenState: 30s # HALF_OPEN 상태로 빨리 전환되어 장애가 복구 될 수 있도록 기본값(60s)보다 작게 설정
        slowCallRateThreshold: 80 # slowCall 발생 시 서버 스레드 점유로 인해 장애가 생길 수 있으므로 기본값(100)보다 조금 작게 설정
        slowCallDurationThreshold: 5s # 위와 같은 이유로 5초를 slowCall로 판단함. 해당 값은 TimeLimiter의 timeoutDuration보다 작아야 함
        registerHealthIndicator: true
        recordFailurePredicate: app.global.config.RestTemplateCircuitRecordFailurePredicate

    instances:
      default:
        baseConfig: default

  timelimiter:
    configs:
      default:
        timeoutDuration: 6s # slowCallDurationThreshold보다는 크게 설정되어야 함
        cancelRunningFuture: true


server:
  port: 8084

